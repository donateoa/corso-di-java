# Test "rest" - 10 domande su REST con Spring Boot

id:Q1
text:Quale metodo HTTP è idempotente secondo lo standard REST?
option:POST
option:PUT
option:PATCH
option:CONNECT
correct:B
answer:PUT è definito idempotente: più chiamate con lo stesso body producono lo stesso stato della risorsa. POST e PATCH in genere non lo sono, CONNECT non è usato per aggiornare risorse REST.


id:Q2
text:Qual è l’uso corretto di un codice 201 Created?
option:Quando crei una risorsa con POST e fornisci Location dell’URI creato
option:Quando aggiorni parzialmente una risorsa
option:Quando la richiesta è malformata
option:Quando il client non è autenticato
correct:A
answer:201 Created si usa per creazione riuscita via POST; va incluso l’header Location con l’URI della nuova risorsa. 400 indica errore di input, 401 è per autenticazione mancante, gli update parziali usano 200/204.


id:Q3
text:Quale annotazione usi per definire un controller REST in Spring Boot?
option:@Controller
option:@RestController
option:@WebService
option:@RestService
correct:B
answer:@RestController combina @Controller e @ResponseBody, restituendo il body direttamente in JSON/XML. @Controller da solo richiede @ResponseBody sui metodi; le altre annotazioni non sono per REST controller Spring.


id:Q4
text:Per aggiornare parzialmente una risorsa, quale combinazione è più appropriata?
option:PATCH con payload JSON e validazione
option:POST senza body
option:GET con query param action=update
option:DELETE seguito da PUT
correct:A
answer:PATCH è pensato per modifiche parziali; in Spring si gestisce con @PatchMapping, validazione e controlli di concorrenza. POST senza body o GET non sono semantici, cancellare e ricreare è inefficiente e rischioso.


id:Q5
text:Quali sono buone pratiche per versionare una API REST? (risposta multipla)
option:Inserire la versione nel path es. /v1/risorse
option:Usare header personalizzati es. Accept: application/vnd.acme.v1+json
option:Cambiare la porta per ogni versione
option:Documentare e mantenere più versioni per un periodo di transizione
correct:A,B,D
answer:Versionare nel path o via media type sono approcci comuni; mantenere più versioni documentate facilita la migrazione. Cambiare porta non è pratico e non scala.


id:Q6
text:Quale risposta HTTP è adeguata per una DELETE riuscita senza body?
option:200 OK con body vuoto
option:204 No Content
option:202 Accepted obbligatorio
option:301 Moved Permanently
correct:B
answer:204 No Content segnala che l’operazione è andata a buon fine e non c’è payload. 200 è accettabile ma 204 è preferito; 202 indica elaborazione asincrona; 301 è per redirect e non pertinente.


id:Q7
text:Quale intestazione HTTP usi per gestire la concorrenza ottimistica?
option:If-Match con ETag
option:User-Agent
option:Referer
option:Retry-After
correct:A
answer:If-Match con l’ETag del client permette di accettare l’update solo se la versione coincide, prevenendo overwrite concorrenti. Le altre intestazioni non gestiscono concorrenza.


id:Q8
text:Quali status code sono corretti per indicare che una risorsa richiesta non esiste? (risposta multipla)
option:404 Not Found
option:410 Gone
option:204 No Content
option:500 Internal Server Error
correct:A,B
answer:404 segnala risorsa non trovata, 410 che è stata rimossa in modo definitivo e noto. 204 indica successo senza contenuto, 500 è per errori server.


id:Q9
text:Qual è il modo più pulito per esporre DTO diversi da entity JPA in un controller?
option:Restituire direttamente le entity
option:Usare mapper (es. MapStruct) o assembler per convertire entity in DTO
option:Usare System.out.println nel controller
option:Serializzare manualmente con concatenazioni di stringhe
correct:B
answer:Separare DTO da entity evita esporre dettagli di persistenza; un mapper/assembler converte tra livelli mantenendo controllo su campi e validazione. Stampare su console o concatenare stringhe non è manutenibile; esporre entity può generare coupling e problemi di sicurezza.


id:Q10
text:Quale delle seguenti è corretta riguardo alla paginazione in REST?
option:Esporre parametri page e size, restituendo metadata (totale, pagina corrente) nel body o header
option:Usare una singola pagina con tutti i dati
option:Forzare sempre page=0 e size fisso
option:Evitarla se i dati sono molti
correct:A
answer:Paginare con parametri page/size e includere metadati consente al client di navigare dataset grandi senza caricare tutto. Una singola pagina non scala; fissare page/size rigidamente limita il client; evitare la paginazione con molti dati è impraticabile e causa problemi di performance.
