# Test "springsecurity" - 10 domande avanzate su Spring Security

id:Q1
text:In Spring Boot 3, qual è il modo raccomandato per configurare HTTP security?
option:Estendere WebSecurityConfigurerAdapter
option:Esporre un bean SecurityFilterChain con la lambda DSL
option:Registrare manualmente i filtri nel web.xml
option:Configurare solo application.properties
correct:B
answer:WebSecurityConfigurerAdapter è deprecato e rimosso; si definisce un bean SecurityFilterChain con la DSL basata su lambda, dichiarando autorizzazioni, csrf, session management e filter order nel codice.


id:Q2
text:Per una REST API con JWT stateless, quale policy di session management è corretta?
option:ALWAYS
option:IF_REQUIRED
option:STATELESS
option:NEVER obbligatorio
correct:C
answer:STATELESS evita la creazione/uso di HttpSession e si affida al token (es. JWT) per l’autenticazione a ogni richiesta. ALWAYS/IF_REQUIRED creano sessioni, mentre NEVER non è pensato per uso con filtri di sicurezza moderni.


id:Q3
text:Quali affermazioni su CSRF in Spring Security 6 sono corrette? (risposta multipla)
option:Per API stateless con bearer token è comune disabilitare CSRF
option:Con form login va lasciato attivo e si usa il token _csrf nel form
option:CSRF è disattivato di default nelle app web
option:Si può cambiare CsrfTokenRepository per memorizzare il token in cookie/header
correct:A,B,D
answer:CSRF è abilitato di default nelle app web; per API stateless con token portato dal client si può disabilitare. Con form login bisogna includere _csrf nel form. È possibile personalizzare il repository (es. CookieCsrfTokenRepository) per gestire token via cookie/header.


id:Q4
text:Come si abilita la sicurezza a livello di metodo (es. @PreAuthorize) in Boot 3?
option:@EnableGlobalMethodSecurity(prePostEnabled = true)
option:@EnableMethodSecurity
option:@EnableSecuredEndpoints
option:@MethodSecurity
correct:B
answer:In Spring Security 6/Boot 3 si usa @EnableMethodSecurity; @EnableGlobalMethodSecurity è obsoleta. L’annotazione abilita @PreAuthorize, @PostAuthorize, @Secured e @RolesAllowed se configurate.


id:Q5
text:Quali passi sono corretti per validare un JWT custom in una REST API? (risposta multipla)
option:Aggiungere un OncePerRequestFilter prima di UsernamePasswordAuthenticationFilter
option:Verificare firma e scadenza del token
option:Creare un Authentication e metterlo nel SecurityContext se valido
option:Forzare la creazione di HttpSession per salvare l’Authentication
correct:A,B,C
answer:Un filtro custom prima di UsernamePasswordAuthenticationFilter legge il token, ne verifica firma/exp e, se valido, costruisce un Authentication nel SecurityContext. Non serve forzare HttpSession in un sistema stateless.


id:Q6
text:Per indurire gli endpoint admin, quali misure sono opportune?
option:Limitare l’accesso a ruoli dedicati e privilegio minimo
option:Forzare MFA e IP allowlist per gli account amministrativi
option:Proteggere gli endpoint sensibili con rate limit e logging/audit
option:Tutte le precedenti
correct:D
answer:A, B e C sono tutte best practice: ruoli minimali, MFA e controlli di rete per gli admin, rate limiting e audit sugli endpoint sensibili. Sommate riducono il rischio di compromissione.


id:Q7
text:Qual è la differenza tra authorities e roles in Spring Security?
option:Nessuna, sono sinonimi
option:I ruoli sono authorities con prefisso ROLE_, usati da hasRole/hasAnyRole
option:Le authorities funzionano solo con LDAP
option:I ruoli funzionano solo con OAuth2
correct:B
answer:Un ruolo è un’autorità con prefisso ROLE_ (es. ROLE_ADMIN). I metodi hasRole/hasAnyRole aggiungono automaticamente il prefisso, mentre hasAuthority verifica il valore esatto. Le authorities non sono legate a un meccanismo d’identità specifico.


id:Q8
text:Configurando un Resource Server JWT in Spring Boot, quali elementi sono necessari? (risposta multipla)
option:Abilitare oauth2ResourceServer().jwt() nella SecurityFilterChain
option:Fornire un jwk-set-uri o una chiave pubblica per la verifica
option:Aggiungere la dipendenza spring-boot-starter-oauth2-resource-server
option:Definire manualmente un AuthenticationManager custom in ogni controller
correct:A,B,C
answer:Serve lo starter resource server, la config oauth2ResourceServer().jwt() e un modo per verificare la firma (JWK set URI o chiave pubblica). Non è necessario creare un AuthenticationManager per controller: la filter chain gestisce l’autenticazione.


id:Q9
text:Quale approccio è corretto per abilitare CORS in modo sicuro su una REST API?
option:Abilitare tutte le origini con \\* e tutti i metodi senza limitazioni
option:Definire un CorsConfiguration con origini/metodi/headers ammessi e maxAge, registrato in SecurityFilterChain
option:Gestirlo con System.out.println
option:Impostare solo un header Access-Control-Allow-Origin nel controller
correct:B
answer:Un CorsConfiguration esplicito (origini, metodi, header ammessi, credenziali, maxAge) registrato via CorsConfigurationSource e applicato in SecurityFilterChain limita la superficie di attacco. Wildcard indiscriminate o log non configurano CORS in modo sicuro.


id:Q10
text:Perché usare PasswordEncoder delegating (es. PasswordEncoderFactories.createDelegatingPasswordEncoder())?
option:Per salvare password in chiaro
option:Per gestire più algoritmi e migrare gli hash nel tempo
option:Per eliminare la necessità di salt
option:Perché è obbligatorio con JDBC
correct:B
answer:Il delegating PasswordEncoder permette di usare un identificatore nell’hash ({bcrypt}, {argon2}, ecc.) così puoi supportare e migrare algoritmi senza rompere utenti esistenti. Non salva in chiaro, non elimina il salt (che è incluso in algoritmi come bcrypt) e non è legato a JDBC.
